<!DOCTYPE html>
<html lang="pt-br">

<head>
</head>

<body>
    <script>
        var digitos = {
            "0": 0,
            "1": 1,
            "2": 2,
            "3": 3,
            "4": 4,
            "5": 5,
            "6": 6,
            "7": 7,
            "8": 8,
            "9": 9,
            "A": 10,
            "B": 11,
            "C": 12,
            "D": 13,
            "E": 14,
            "F": 15,
            "G": 16,
            "H": 17,
            "I": 18,
            "J": 19,
            "K": 20,
            "L": 21,
            "M": 22,
            "N": 23,
            "O": 24,
            "P": 25,
            "Q": 26,
            "R": 27,
            "S": 28,
            "T": 29,
            "U": 30,
            "V": 31,
            "W": 32,
            "X": 33,
            "Y": 34,
            "Z": 35,
            "a": 36,
            "b": 37,
            "c": 38,
            "d": 39,
            "e": 40,
            "f": 41,
            "g": 42,
            "h": 43,
            "i": 44,
            "j": 45,
            "k": 46,
            "l": 47,
            "m": 48,
            "n": 49,
            "o": 50,
            "p": 51,
            "q": 52,
            "r": 53,
            "s": 54,
            "t": 55,
            "u": 56,
            "v": 57,
            "w": 58,
            "x": 59,
            "y": 60,
            "z": 61,
            "+": 62,
            "/": 63
        };
        var caracteres = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "+", "/"];


        // nbx = numero na base x
        // recebe um numero em uma base especifica
        // bx = base x
        // recebe a base ao qual o numero esta codificiado
        function bxb10(nbx, bx) {
            // uma função é um grupo de codigo que pode ser chamado por um no nome
            // usa-se bxb10("123F", 16); para chamar a função

            if (bx < 2 || bx > 64) // verifica se o valor de base é suportado
                return;

            nbx = nbx.toString().split("").reverse();
            // .toString() transforma nbx em texto
            // .split("") separa todos os caracteres em um vetor "abc" => ['a','b','c'] => nbx[0] = 'a'
            // .reverse() inverte o vetor ['a','b','c'] => ['c','b','a'] 
            let sinal = 1; // guarda o sinal
            let resultado = 0; // guarda o resultado
            if (nbx[nbx.length - 1] == "-") { // nbx é um vetro, nbx.length retorna o numero de elementos, logo nbx[nbx.length - 1] retorna o ultimo elemento
                nbx.splice(nbx.length - 1, 1); // remove o ultimo elemento
                sinal *= -1; // inverte o sinal
            }
            for (let i = 0; i < nbx.length; i++) { // escaneia todas as posições
                resultado += digitos[nbx[i]] * Math.pow(bx, i); // digitos contrem a relção 'a' = 36
                // resultado recebe resultado + valor do caractere * base de destino elevado a posição no vetor
            }
            return sinal * resultado; // retorna resultado com sinal
        }
        // nb10 = numero na base 10
        // recebe um numero na base 10
        // bx = base x
        // recebe a base ao qual o numero devera ser codificiado
        function b10bx(nb10, bx) {

            if (bx < 2 || bx > 64) // verifica se o valor de base é suportado
                return;

            let resultado = ""; // resultado é um texto
            let sinal = ""; // sinal é um texto

            if (nb10 == 0) // caso entrada 0, retorna 0; conta não funciona corretamente com 0
                return 0;

            if (nb10 < 0) { // caso nb10 <0, retorna nb10 positiva e salva o sinal
                sinal = "-";
                nb10 *= -1;
            }


            while (nb10 > 0) { // enquanto nb10 > 0
                resultado += caracteres[nb10 % bx]; // não interprete isto como uma soma, esta sendo feita uma junção de caracteres
                //ex: "10" + "2" => "102"
                // nb10 % bx obtem o resto da divisão, e caracteres[nb10 % bx] retorna o caractere correspondente
                nb10 = (nb10 - nb10 % bx) / bx; // realzia a divisão euclidiana (javascript não possui div)
            }
            return sinal + resultado.split("").reverse().join(""); // junta o sinal ao numero
            // .split("") separa todos os caracteres em um vetor "cba" => ['c','b','a']
            // .reverse() inverte os caracteres neste vetor ['c','b','a'] => ['a','b','c']
            // .join("") junta todo o caracteres neste vetor ['a','b','c'] => "abc"
        }


        // nbx = numero na base x
        // recebe um numero em uma base especifica
        // bx = base x
        // recebe a base ao qual o numero esta codificiado
        // by = base y
        // recebe a base ao qual o numero devera ser codificiado
        function bxby(nbx, bx, by) { // coverte da base x para a base y
            // bxb10() converte da base x para a base 10
            // b10bx() converte da base 10 para a base x
            return b10bx(bxb10(nbx, bx), by);
        }

        function somaBinaria(b1, b2) {

            console.log((parseInt(b1, 2) + parseInt(b2, 2)).toString(2)); // soma binaria nativa, converte para inteiros, soma, converte para binario

            // forma "manual"
            b1 = b1.split("");
            b2 = b2.split("");
            let tamanho;
            if (b1.length > b2.length) {
                tamanho = b1.length;
            } else {
                tamanho = b2.length;
            }
            let sup = 0;
            let sub = [0, 0];
            let resultado = "";
            for (var i = 1; i <= tamanho; i++) {
                if (i <= b1.length) {
                    sub = somaDigito(sup, b1[b1.length - i]);
                } else {
                    sub = ['0', sup];
                }
                sup = 0;
                if (sub[0] == '1')
                    sup = '1'

                if (i <= b2.length) {
                    sub = somaDigito(sub[1], b2[b2.length - i]);
                }
                if (sub[0] == '1')
                    sup = '1'
                resultado = sub[1] + resultado;
            }
            if (sup == '1') {
                resultado = sup + resultado;
            }
            return resultado;
        }

        function somaDigito(digito1, digito2) {
            digito1 = (digito1 == '1');
            digito2 = (digito2 == '1');
            // essa comparação é realizada a nivel de hardware
            // não se cria um programa para somar dois numeros binairos, se cria um hardware
            return [
                (digito1 && digito2),
                (digito1 ^ digito2) // equivalente a (!(digito1 && digito2) && (digito1 || digito2)), xor
            ];
        }
    </script>
</body>

</html>